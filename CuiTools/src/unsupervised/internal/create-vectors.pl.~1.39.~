#!/usr/bin/perl -w

=head1 HEAD

create-vectors.pl 

=head1 SYNOPSIS

This program creates the instance and sense vectors 
for the unsupervised-disambiguate wrapper program.

=head1 DESCRIPTION

This program uses programs from SenseClusters version 
0.95 to create vecctors for the unsupervised word 
sense disambiguation approach used by CuiTools.

=head1 USAGE

perl create-vectors.pl [OPTIONS] DIRECTORY

=head1  DIRECTORY 

Directory is the location where all the files generated by 
create-vectors reside.

=head2 Required Arguments:

=head3 --training FILE

File containing the training data. 

The data is expected to be in plain format and the name of file 
is expected to have the following format:

    <target word>.trainingdata

=head3 --senses FILE

File containing the possible concepts of the target word. 
The format required for the sense file is:

<TAG>|<TERM>|<Semantic Type>|<CUI>

For example, one of the possible concepts for the target word 
adjustment is:

Adjustment <1> (Individual Adjustment)|inbe, Individual Behavior|C0376209

=head3 --instances FILE

File containing the instances. The data is expected to be in sval2 format.

=head3 --tw TARGET WORD

The word that is being disambiguated

=head2 First Order Arguments:


=head3 --cuidef

Use the UMLS CUI extended definition of the possible concepts as context 
from the UMLS-Interface package.


=head3 --config CONFIGURATION FILE

The configuration file for the --cuidef option. This is used by the UMLS-Interface 
package to create the extended definition. The default is to use all of the UMLS 
and all relations to create the extended definition. 

=head3 --summary FILE

File containing a text description of each possible concept for each 
possible target word in the source directory. The format is as follows:

    <tw>.<concept>.<summary>
    ...

=head2 Second Order Arguments: 


=head4 --ngramcount "OPTIONS"

The Ngram Statistic Package (NSP) count.pl program is used to obtain 
the counts for hte first and second-order co-occurrence vectors. The 
options specify any additional options to be passed to count.pl program.
                 
Note: All the options must be within double quotes, as
      would be passed to the program at command line.

Current 1st order options are:
 --ngram 1 
 --newLine 
 --token $ENV{CUITOOLSHOME}/default_options/token.regex
 --remove 2 
 --uremove 150 
 --stop $ENV{CUITOOLSHOME}/default_options/stoplist $directory/$tw.unigrams $opt_training

Current 2nd order options are:
 --ngram 2 
 --extended 
 --newLine 
 --token $ENV{CUITOOLSHOME}/default_options/token.regex 
 --remove 2 
 --uremove 150 
 --stop $ENV{CUITOOLSHOME}/default_options/stoplist  


=head3 --stop STOPFILE

A file of Perl regexes that define the stop list of words to be excluded from 
the features.

STOPFILE could be specified with two modes -

AND mode - declared by including '@stop.mode=AND' on the first line of the
STOPFILE.
         - ignores word pairs in which both words are stop words.

OR mode - declared by including '@stop.mode=OR' on the first line of the
STOPFILE.
        - ignores word pairs in which either word is a stop word.

Both modes exclude stop words from unigram features.

Default is OR mode.

=head2 Program Arguments: 
=head3 --help

Displays the quick summary of program options.

=head3 --version

Displays the version information.

=head1 OUTPUT

Vectors located in the <target word>.vectors files.

=head1 PROGRAM REQUIREMENTS

=over

=item * Perl (version 5.8.5 or better) - http://www.perl.org

=item * Text::NSP - http://search.cpan.org/dist/Text-NSP

=back

=head1 AUTHOR

 Bridget T. McInnes, University of Minnesota, Twin Cities

=head1 COPYRIGHT

Copyright (c) 2007-2008,

 Bridget T. McInnes, University of Minnesota, Twin Cities
 bthomson at cs.umn.edu

 Ted Pedersen, University of Minnesota Duluth
 tpederse at d.umn.edu

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to 

 The Free Software Foundation, Inc.,
 59 Temple Place - Suite 330,
 Boston, MA  02111-1307, USA.

=cut

my $debug = 1;

use lib "$ENV{CUITOOLSHOME}/lib/";

use Getopt::Long;

use UMLS::Interface;

#use WordNet::QueryData;
#use WordNet::Similarity::GlossFinder;

eval(GetOptions( "version", "help", "training=s", "instances=s", "cuidef", "gloss", "tw=s", "stop=s", "senses=s", "context=s", "vectors=s", "similarity=s", "measure=s", "verbose", "config=s", "username=s", "password=s", "hostname=s", "database=s", "socket=s", "bigram=s", "lc", "unigram=s", "summary=s", "ngramcount=s", "format=s")) or die ("Please check the above mentioned option(s).\n");


#  if help is defined, print out help
if( defined $opt_help ) {
    $opt_help = 1;
    &showHelp();
    exit;
}

#  if version is requested, show version
if( defined $opt_version ) {
    $opt_version = 1;
    &showVersion();
    exit;
}

if($#ARGV < 0) {
    $opt_help = 1;
    &minimalUsageNotes();
    exit;
}

my $format = "mm"; 
if(defined $opt_format) { 
    $format = $opt_format; 
}

if(!(defined $opt_cuidef)  and 
   !(defined $opt_summary) and
   !(defined $opt_gloss)) { 
    $opt_cuidef = 1;
}

my $vectors = "o1";
if(defined $opt_vectors) {
    $vectors = $opt_vectors;
}

my $measure = "ll"; 
if(defined $opt_measure) { 
    $measure = $opt_measure;
}

my $context = "terms";
if(defined $opt_context) { 
    $context = $opt_context;
}

my $directory = shift;
if(-e $directory) {
    if(-d $directory) {
	# all is good
    }
    else {
	print STDERR "DIRECTORY should be a directory\n";
	&showHelp();
	exit;
    }
}
else {
    system "mkdir $directory";
}

my $tw = $opt_tw;
if(!(defined $opt_tw) ) {
    print STDERR "Target word option (--tw) must be defined\n";
    &showHelp();
    exit;
}

if( (!(defined $opt_instances)) || 
    (!(defined $opt_senses))) {
    print STDERR "The instances (--instances) and senses (--senses) options must be defined\n";
    &showHelp();
    exit;
}

if( !(defined $opt_training) ) {
    if($vectors eq "o1") { 
	if(! (defined $opt_unigram) ) { 
	    print STDERR "The training (--training) or unigram (--unigram) option must be defined\n";
	    &showHelp();
	    exit;
	}
    }
    else { 
	if(! (defined $opt_bigram) ) { 
	    print STDERR "The training (--training) or bigram (--bigram) option must be defined\n";
	    &showHelp();
	    exit;
	}
    }
}

my $stoplist = "$ENV{CUITOOLSHOME}/default_options/stoplist";
if( defined $opt_stop ) {
    $stoplist = $opt_stop;
}

#  this config file sets umls to extract definitions from all of the
#  sources in the UMLS - this is different than the --config option
#  which is used by the --similarity option.
my $configfile = "$ENV{CUITOOLSHOME}/default_options/definition.config";

my $database = "umls";
my $hostname = "localhost";
my $socket   = "/tmp/mysql.sock";

if(defined $opt_database) {
    $database = $opt_database;
}
if(defined $opt_hostname) {
    $hostname = $opt_hostname;
}
if(defined $opt_socket) {
    $socket = $opt_socket;
}

my $umls = "";
my %option_hash = ();

$option_hash{"realtime"} = 1;

if(defined $opt_config) {
    $option_hash{"config"} = $opt_config;
}
if(defined $opt_username) {
    $option_hash{"username"} = $opt_username;
}
if(defined $opt_database) {
    $option_hash{"database"} = $database;
}
if(defined $opt_password) {
    $option_hash{"password"} = $opt_password;
}
if(defined $opt_hostname) {
    $option_hash{"hostname"} = $hostname;
}
if(defined $opt_socket) {
    $option_hash{"socket"}   = $socket;
}

$umls = UMLS::Interface->new(\%option_hash); 
die "Unable to create UMLS::Interface object.\n" if(!$umls);

#  Not ready to add wordnet for the release yet
#my $wn = WordNet::QueryData->new();
#if(!$wn) {
#  print STDERR "Unable to create WordNet object.\n";
#  exit 1;
#}
#my $gf = WordNet::Similarity::GlossFinder->new($wn);
my $gf; 

my $training_file = "";
if(defined $opt_training) { 
    $training_file = $opt_training; 
}

my $instance_file = &create_instance_files();
my $sense_file    = &create_sense_files();

&create_vectors($training_file, $instance_file, $sense_file);

sub create_vectors { 
    
    if($debug) { print "In create_vectors\n"; }
    
    my $training_file = shift;
    my $instance_file = shift;
    my $sense_file    = shift;

    #print "TRAIN FILE: $training_file\n";
    #print "SENSE FILE: $sense_file\n";
    
    my $target_word = $tw;

    my $ngramcount = "";
    if(defined $opt_ngramcount) { $ngramcount = $opt_ngramcount; }

    my $options = "";
    if(defined $opt_stop) { $options .= "--stop $opt_stop "; }
    
    my $choicefile = "$ENV{NLMWSDHOME}/Reviewed_Results/$target_word/choices";
    if(defined $opt_senses) {
	$choicefile = $opt_senses;
    }
    open(CHOICE, $choicefile) || die "Could not open $choicefile\n";
    my $choices = 0; while(<CHOICE>) { $choices++; }
	
    my $pro_sense_file    = $sense_file . ".pro";
    my $pro_instance_file = $instance_file . ".pro";
    
    if($opt_verbose) {
	print "preprocess.pl --token $ENV{CUITOOLSHOME}/default_options/token.regex --removeNotToken --xml $pro_sense_file --nocount $sense_file\n";
    }
    system "preprocess.pl --token $ENV{CUITOOLSHOME}/default_options/token.regex --removeNotToken --xml $pro_sense_file --nocount $sense_file";
    
    if($opt_verbose) {
	print "preprocess.pl --token $ENV{CUITOOLSHOME}/default_options/token.regex --removeNotToken --xml $pro_instance_file --nocount $instance_file\n";
    }
    system "preprocess.pl --token $ENV{CUITOOLSHOME}/default_options/token.regex --removeNotToken --xml $pro_instance_file --nocount $instance_file";
    
    #  first order vectors
    if($vectors eq "o1") {
	
	my $unigramfile = "";
	if(! (defined $opt_unigram) ) { 
	    if($opt_verbose) {
		print "count.pl $ngramcount --ngram 1 --newLine --token $ENV{CUITOOLSHOME}/default_options/token.regex --nontoken $ENV{CUITOOLSHOME}/default_options/nontoken.regex --remove 2 --uremove 150 --stop $stoplist $directory/$tw.unigrams $opt_training\n";
	    }
	    system "count.pl $ngramcount --ngram 1 --newLine --token $ENV{CUITOOLSHOME}/default_options/token.regex --nontoken $ENV{CUITOOLSHOME}/default_options/nontoken.regex --remove 2 --uremove 150 --stop $stoplist $directory/$tw.unigrams $opt_training";
	    $unigramfile = "$directory/$tw.unigrams";
	}
	else { 
	    $unigramfile = $opt_unigram;
	}
    	if($opt_verbose) {
	    print "nsp2regex.pl $unigramfile > $directory/$tw.regex\n";
	}
	system "nsp2regex.pl $unigramfile > $directory/$tw.regex";
	
	if($opt_verbose) {
	    print "order1vec.pl --showkey $pro_instance_file $directory/$tw.regex > $directory/$tw.instances.vectors\n";
	}
	system "order1vec.pl --showkey $pro_instance_file $directory/$tw.regex > $directory/$tw.instances.vectors";
    }
    
    #  otherwise we are creating second order vectors
    else {
	
	#my $bigramfile = "";
	#if(! (defined $opt_bigram) ) {
	    #if($opt_verbose) {
		#print "count.pl $ngramcount --ngram 2 --extended --newLine --token $ENV{CUITOOLSHOME}/default_options/token.regex --nontoken $ENV{CUITOOLSHOME}/default_options/nontoken.regex --remove 2 --uremove 150 --window 50 --stop $stoplist $directory/$tw.bigrams $opt_training\n";
	    #}
	    #system "count.pl $ngramcount --ngram 2 --extended --newLine --token $ENV{CUITOOLSHOME}/default_options/token.regex --nontoken $ENV{CUITOOLSHOME}/default_options/nontoken.regex --remove 2 --uremove 150 --window 50 --stop $stoplist $directory/$tw.bigrams $opt_training";
	    #$bigramfile = "$directory/$tw.bigrams";
	#}
	#else { 
	    #$bigramfile = $opt_bigram;
	#}
	
	#if($opt_verbose) {
	       #print "statistic.pl --score 3.84  --precision 06 $measure  $directory/$tw.statistic $bigramfile\n";
	#}
	#system "statistic.pl --score 3.84  --precision 06 $measure  $directory/$tw.statistic $bigramfile";
	
        #my $statfile = "/home/bridget/research/data/medline/bigrams/bigramWords.ll"; 
	my $statfile = "/home/bridget/research/data/medline/2-gram/2-gram.2015.ll"; 
	
	if($opt_verbose) {
	    #print "wordvec.pl --format f16.06 --feats $directory/$tw.features --dims $directory/$tw.dims --wordorder follow $directory/$tw.statistic > $directory/$tw.wordvec_presvd\n"; 
	    print "wordvec.pl --format f16.06 --feats $directory/$tw.features --dims $directory/$tw.dims --wordorder follow $statfile > $directory/$tw.wordvec_presvd\n"; 
	}
	#system "wordvec.pl  --format f16.06 --feats $directory/$tw.features --dims $directory/$tw.dims --wordorder follow $directory/$tw.statistic > $directory/$tw.wordvec";
	system "wordvec.pl  --format f16.06 --feats $directory/$tw.features --dims $directory/$tw.dims --wordorder follow $statfile> $directory/$tw.wordvec";
	
	if($opt_verbose) {
	    print "nsp2regex.pl $directory/$tw.features > $directory/$tw.testregex\n";
	}
	system "nsp2regex.pl $directory/$tw.features > $directory/$tw.testregex";
	
	if($opt_verbose) {
	    print "order2vec.pl --showkey --format f16.06 $pro_instance_file $directory/$tw.wordvec $directory/$tw.testregex > $directory/$tw.instances.vectors\n";
	}

	system "order2vec.pl --showkey --format f16.06 $pro_instance_file $directory/$tw.wordvec $directory/$tw.testregex > $directory/$tw.instances.vectors";
    }

    open(VECTOR, "$directory/$tw.instances.vectors") || 
	die "Could not open vector file: $directory/$tw.instances.vectors\n";
    
    my $keyname = <VECTOR>;
    $keyname=~/<keyfile name=\"(.*?)\"\/>/;
    my $instancekey = $1;
    if($opt_verbose) {
	print "Removing instance key file: $instancekey\n";
    }
    if(-e $instancekey) {
	system "rm $instancekey";
    }
    
    if($vectors eq "o1") {
	
	if($opt_verbose) {
	    print "order1vec.pl  --showkey $pro_sense_file $directory/$tw.regex > $directory/$tw.senses.vectors\n";
	}
	system "order1vec.pl --showkey $pro_sense_file $directory/$tw.regex > $directory/$tw.senses.vectors";
    }
    else {
	if($opt_verbose) {
	    print "order2vec.pl --showkey --format f16.06 $pro_sense_file $directory/$tw.wordvec $directory/$tw.testregex > $directory/$tw.senses.vectors\n";
	}
	system "order2vec.pl --showkey --format f16.06 $pro_sense_file $directory/$tw.wordvec $directory/$tw.testregex > $directory/$tw.senses.vectors";
    }
    
    open(VECTOR, "$directory/$tw.senses.vectors") || 
	die "Could not open vector file: $directory/$tw.senses.vectors\n";
    $keyname = <VECTOR>;
    $keyname=~/<keyfile name=\"(.*)\"\/>/;
    my $sensekey = $1;
    if($opt_verbose) {
	print "Removing sense key file: $sensekey\n";
    }
    if(-e $sensekey) {
	system "rm $sensekey";
    }
} 
   
sub create_sense_files {
    
    if($debug) { print "In create_sense_files ($context)\n"; }
        
    my %summaries = ();
    if(defined $opt_summary) { 
	
	print STDERR "USING SUMMARY\n";
	open(SUMMARY, $opt_summary) || die "Could not open file $opt_summary\n";
	
	print STDERR "Getting summary for $tw\n";
	while(<SUMMARY>) { 
	    chomp;
	    $_=~/(.*?)\.(C[0-9]+)\./;
	    my $tw = $1; 
	    my $id = $2; 
	    my $summary = $'; #'
	
	    if(exists $summaries{$tw}{$id}) { 
		$summaries{$tw}{$id} .= "$summary ";
	    }
	    else {
		$summaries{$tw}{$id} = "$summary ";
	    }
	}
    }
    
    my $input_file   = $opt_senses;
    my $plain_file   = "$directory/$tw.senses.plain";
    my $sval_file    = "$directory/$tw.senses.sval"; 
    my $key_file     = "$directory/$tw.senses.key";

    open(FILE, $input_file) || die "Could not open sense file : $input_file\n";
    open(PLAIN, ">$plain_file") || die "Could not open plain file: $plain_file\n";
    open(KEY, ">$key_file") || die "Could not open key file: $key_file\n";
    
    while(<FILE>) {
	chomp;
	
	if($_=~/^\s*$/) { next; }
	
	my($tag, $concept, $semantics, $cui) = split/\|/;
	my $line = "";  

	if(defined $opt_cuidef) {
	    $line .= &getCuiDef($cui); 
	    
	}
	elsif(defined $opt_summary) { 
	    $line .= $summaries{$tw}{$cui}; 
	}

	elsif(defined $opt_gloss) { 
	    $line .= &getGloss($cui); 
	}
	#elsif($context ne "terms") { 
	#    $line = &getContext($line); 
	#}
	
	my $term = $concept;
	if($concept=~/\((.*?)\)/) {
	    $term = $1;
	}
	else {
	    $term=~s/\<(.*?)\>//g;
	}
	
	if(defined $opt_lc) { 
	    $line = lc($line); 
	}

	$tag = $cui; 

	print KEY "<instance id=\"$cui\"\/> <sense id=\"$tag\"\/>\n";

	if(defined $line) {
	    print PLAIN "<head item=\"$tw\" instance=\"$cui\" sense=\"$tag\">$term</head> $line\n";}
	else {
	    print PLAIN "<head item=\"$tw\" instance=\"$cui\" sense=\"$tag\">$term</head>\n";
	}

    }
    
    call_text2sval($plain_file, $sval_file, $key_file);
    
    
    return $sval_file;
}

##############################################################################
#
##############################################################################
sub create_instance_files {

    if($debug) { print "In create_instance_files\n"; }
    
    my $input_file = $opt_instances;
    my $plain_file = "$directory/$tw.instances.plain";
    my $key_file   = "$directory/$tw.instances.key";
    my $sval_file  = "$directory/$tw.instances.sval";
    
    if($format=~/sval2/) { 
	return $input_file; 
    }
    else { 
	if($format=~/mm/) { 
	    call_mm2plain($input_file, $plain_file, $key_file, "yes");
	}
	elsif($format=~/plain/) { 
	    create_plain_file($input_file, $plain_file, $key_file); 
	}
    	call_text2sval($plain_file, $sval_file, $key_file);
	
	return $sval_file;
    }
}


##############################################################################
#  create plain file
##############################################################################
sub create_plain_file { 
    my $input_file = shift; 
    my $plain_file = shift; 
    my $key_file = shift; 

    open(PLAIN, ">$plain_file") || die "Could not open file ($plain_file)\n";
    open(KEY, ">$key_file")     || die "Could not open file ($key_file)\n";
    open(INPUT, $input_file)    || die "Could not open file ($input_file)\n";

    while(<INPUT>) { 
	chomp;
	$_=~/<head item=\"(.*?)\" instance=\"(.*?)\" sense=\"(.*?)\">(.*?)<\/head>/; 
	my $item = $1; 
	my $instance = $2; 
	my $sense = $3; 
	my $tw = $4; 

	$_=~s/<head item=\"(.*?)\" instance=\"(.*?)\" sense=\"(.*?)\">(.*?)<\/head>/<head>$tw<\/head>/g; 
	
	
	print PLAIN "$_\n";
	print KEY "<instance id=\"$instance\"/> <sense id=\"$sense\"/>\n";
    }
    close INPUT; close PLAIN; close KEY; 
}
	    
##############################################################################
# run text2sval program
##############################################################################
sub call_text2sval {
    
    if($debug) { print "   calling text2sval\n"; }

    my $input_file  = shift;
    my $output_file = shift;
    my $key_file    = shift;
    
    my $options = "--remove "; 
    if($key_file ne "") { $options .= "--key $key_file "; }

    print STDERR "text2sval.pl $options $input_file > $output_file\n";
    system "text2sval.pl $options $input_file > $output_file";
}

##############################################################################
#  run compoundify program
##############################################################################
sub call_compoundify { 
    if($debug) { print "    calling compoundify\n"; }
    
    my $input_file = shift; 
    my $output_file= shift; 
    
    print STDERR "compoundify.pl $opt_compoundfile $input_file > $output_file"; 
    system "compoundify.pl $opt_compoundfile $input_file > $output_file"; 
    
    return $output_file; 
}

##############################################################################
# run mm2plain program
##############################################################################    
sub call_mm2plain {

    if($debug) { print "   calling mm2plain\n"; }

    my $input_file  = shift;
    my $output_file = shift;
    my $key_file    = shift;
    my $sense_info  = shift;

    #  set the options
    my $options     = "";
    
    if($sense_info ne "") { $options  = "--senseinfo ";     }
    if($key_file   ne "") { $options .= "--key $key_file "; }

    if(defined $opt_lc)      { $options .= "--lc "; }
    if(defined $opt_context) { $options .= "--context $context "; }

    #  call mm2plain
    print "mm2plain.pl $options $input_file > $output_file\n";
    system "mm2plain.pl $options $input_file > $output_file";
}

##############################################################################
#  set the similarity options if --similarity is defined
##############################################################################
sub set_similarity_options {

    if(! (defined $opt_similarity) ) {
	return "";
    }

    my $options = "--similarity ";
    $options .= "--meausure $opt_similarity "; 
    
    if(defined $opt_username) { $options .= "--username $opt_username "; }
    if(defined $opt_password) { $options .= "--password $opt_password "; }
    if(defined $opt_hostname) { $options .= "--hostname $opt_hostname "; }
    if(defined $opt_socket)   { $options .= "--socket   $opt_socket ";   }
    if(defined $opt_config)   { $options .= "--config   $opt_config ";   }
	
    return $options;
}

##############################################################################
#
##############################################################################
sub getWNSynsets
{
  my $word = shift;
  my $pos;
  my $sense;
  my $key;
  my @senses;
  return () if(!defined $word);

  # First separately handle the case when the word is in word#pos or
  # word#pos#sense form.
  if($word =~ /\#/)
  {
    if($word =~ /^([^\#]+)\#([^\#])\#([^\#]+)$/)
    {
      $word = $1;
      $pos = $2;
      $sense = $3;
      return () if($sense !~ /[0-9]+/ || $pos !~ /^[nvar]$/);
      @senses = $wn->querySense($word."\#".$pos);
      foreach $key (@senses)
      {
        if($key =~ /\#$sense$/)
        {
          return ($key);
        }
      }
      return ();
    }
    elsif($word =~ /^([^\#]+)\#([^\#]+)$/)
    {
      $word = $1;
      $pos = $2;
      return () if($pos !~ /[nvar]/);
    }
    else
    {
      return ();
    }
  }
  else
  {
    $pos = "nvar";
  }

  # Get the senses corresponding to the raw form of the word.
  @senses = ();
  foreach $key ("n", "v", "a", "r")
  {
    if($pos =~ /$key/)
    {
      push(@senses, $wn->querySense($word."\#".$key));
    }
  }

  # If no senses corresponding to the raw form of the word,
  # ONLY then look for morphological variations.
  if(!scalar(@senses))
  {
    foreach $key ("n", "v", "a", "r")
    {
      if($pos =~ /$key/)
      {
        my @tArr = ();
        push(@tArr, $wn->validForms($word."\#".$key));
        push(@senses, $wn->querySense($tArr[0])) if(defined $tArr[0]);
      }
    }
  }
  return @senses;
}

##############################################################################
#  function to return the context of the string
##############################################################################
sub getContext {

    if($debug) { print "   calling getContext\n"; }
    
    my $line = shift;
    
    if($context eq "terms") { return $line; }
    
    my $plain  = "$directory/create-vectors.plain";
    my $prolog = "$directory/create-vectors.prolog";
    my $mm     = "$directory/create-vectors.mm"; 
    my $lfile  = "$directory/create-vectors.line"; 

    system "rm -rf $plain $prolog $mm $lfile";
    
    open(getContextPLAIN, ">$plain") || die "Could not open file ($plain)"; 
    
    print getContextPLAIN "$line"; close getContextPLAIN;

    system "plain2prolog.pl --log $directory $prolog $plain";
    system "prolog2mm.pl $mm $prolog";
    system "mm2plain.pl --context $context $mm/Unknown.mm > $lfile"; 

    open(getContextLINE, $lfile) || die "Could not open file ($lfile)\n";
    
    my $rline = ""; 
    while(<getContextLINE>) {
	chomp;
	$rline .= "$_ "; 
    } close getContextLINE; 
    
    $rline=~s/\s+/ /g; 
    $rline=~s/^\s*//g; 
    $rline=~s/\s*$//g; 
    
    return $rline;
}

##############################################################################
#  function to return the concept's wordnet gloss
##############################################################################
sub getGloss {

    my $cui = shift; 

    my @terms = $umls->getAllTerms($cui);
    
    my %cleaned = (); my $line = ""; 

    foreach my $term (@terms) {
	if($term=~/SCTSPA/) { next; }
	if($term=~/ICPC[A-Z]+/) { next; }
	$term=~/(.*?) - [A-Z0-9,]+/;
	my $item = $1;
	
	my @ts = ();
	
	if($item=~/[\(\[](.*?)[\]\)] or [\(\[](.*?)[\)\]]/) {
	    while($item=~/[\(\[]([a-z\s\,]+)[\)\]]/g) {
		my $f = $1;
		if($f ne "finding" && $f ne "disorder")  {
		    push @ts, $f;
		}
	    }
	}
	else { push @ts, $item; }
	
	foreach my $t (@ts) {
	    
	    $t=~s/\(.*?\)//g;
	    $t=~s/\[.*?\]//g;
	    $t=~s/\<.*?\>//g;
	    $t=~s/[,:-]//g;
	    $t=~s/\.//g;
	    $t=~s/\(//g;
	    $t=~s/\)//g;
	    $t=~s/unspecified//g;
	    $t=~s/nos//g;
	    $t=~s/\s+/ /g;
	    $t=~s/\s+$//g;
	    if($t=~/^[a-z]$/) { next; }
	    if($t=~/^\s*$/)   { next; }
	    $cleaned{$t}++;
	}
	foreach my $term (sort keys %cleaned) {
	    
	    $term=~s/^\s*//g;
	    $term=~s/\s*$//g;
	    my $w = $term . "#n#1";
	    
	    $w=~s/\s+/ /g;
	    
	    my ($firstStringArray, $secondStringArray, $weightsArray, $functionsStringArray) 
		= $gf->getSuperGlosses($w, $w);
	    
	    my $string = join " ", @{$firstStringArray};
	    $string=~s/\s*$//g;
	    $string=~s/^\s//g;
	    
	    if($string ne $term) { 
		$line .= "$string ";
	    }
	}
    }
    
    return $line; 
}

##############################################################################
#  function to return the concept's umls extended definition
##############################################################################
sub getCuiDef { 
    my $cui = shift; 

    my $line = ""; 
    my $rdefs = $umls->getExtendedDefinition($cui); 
    foreach my $d (@{$rdefs}) { 
	my($info, $def) = split/\s*\:\s*/, $d;
	$line .= "$def "; 
    }
    return $line;
}

##############################################################################
#  function to create a timestamp
##############################################################################
sub time_stamp {
    my ($stamp);
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    
    $year += 1900;
    $mon++;
    $d = sprintf("%4d%2.2d%2.2d",$year,$mon,$mday);
    $t = sprintf("%2.2d%2.2d%2.2d",$hour,$min,$sec);
    
    $stamp = $d . $t;
    return($stamp);
}

##############################################################################
#  function to output minimal usage notes
##############################################################################
sub minimalUsageNotes {
    
    print STDERR "Usage: create-vectors.pl [OPTIONS] DIRECTORY\n";
    print STDERR "Type create-vectors.pl --help for help.\n\n";
}

##############################################################################
#  function to output help messages for this program
##############################################################################
sub showHelp() {

    print "Usage: create-vectors.pl [OPTIONS] DIRECTORY\n\n";
    

    print "This program creates the instance and sense vectors \n";
    print "for the unsupervised-disambiguate wrapper program.\n\n";


    print "Required Arguments:\n\n";


    print "--training FILE          File containing the training data. The\n";
    print "                         data is expected to be in plain\n";
    print "                         format. \n\n"; 

    print "--senses FILE            File containing the possible concepts\n";
    print "                         of the target word. Please see perldoc\n";
    print "                         for formatting\n";

    print "--instances FILE         File containing the instances.\n\n";

    print "--tw TARGET WORD         The word that is being disambiguated\n\n";


    print "First Order Options: \n\n";

    print "--cuidef                 The UMLS CUI dextended efinition of the \n";
    print "                         possible concepts as context\n\n";
    
    print "--config CONFIGURATION   UMLS-Interface configuration file\n\n";

    print "--summary FILE           Use the text information in the file\n";
    print "                         as context\n\n";

    print "Second Order Options: \n\n";

    print "--stop STOPFILE          A file of Perl regexes that define the\n";
    print "                         stop list of words to be excluded from\n";
    print "                         the features.\n\n";

    print "--ngramcount OPTIONS     Additional options for count.pl when creating\n";
    print "                         The first or second order vectors\n";

    print "Program Options:\n\n";
    
    
    print "--vectors [o1|o2]        Use first order (o1) or second order (o2)\n";
    print "                         vectors. Default: o1\n\n";
	
    print "--version                Prints the version number\n\n";
 
    print "--help                   Prints this help message.\n\n";
}

##############################################################################
#  function to output the version number
##############################################################################
sub showVersion {
    print '$Id: create-vectors.pl,v 1.39 2016/01/20 18:16:43 btmcinnes Exp $';
    print "\nCopyright (c) 2008, Ted Pedersen & Bridget McInnes\n";
}

##############################################################################
#  function to output "ask for help" message when user's goofed
##############################################################################
sub askHelp {
    print STDERR "Type create-vectors.pl --help for help.\n";
}
